syntax = "proto3";

import "google/protobuf/descriptor.proto";
import "entity.feature.dto.proto";
import "entity.feature.options.proto";
import "entity.feature.method.options.proto";
import "google/api/http.proto";
import "google/api/field_behavior.proto";


package entity.feature.method;
// TODO: в опции дефолты и сделать RequestTemplate, RequestTemplate в полях метода
extend google.protobuf.MessageOptions {
  dto.RequestTemplate request_template = 2996;
  dto.ResponseTemplate response_template = 2997;
}

// TODO: в опции дефолты, обработать поля метода и переопределить опции
message Method {
  option (name_template) = "Method{EntityTypeName}";
  option (request_name) = "Method{EntityTypeName}Request";
  option (response_name) = "Method{EntityTypeName}Response";
  option (response_template) = {entity:{}};
  option (request_template) = {entity:{}};
  option (leading_comment) = "Метод для сущности {EntityTypeName}";
  option (http_rule) = {
    post: "/{HttpRoot}/method",
    body: "*"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  string name_template = 1;
  string request_name = 2;
  string response_name = 3;
  string leading_comment = 4;
  // TODO: сделать подстановки в additional_bindings
  google.api.HttpRule http_rule = 5;
  // TODO: вычислить key_field_behavior для ключевых полей
  // Строгость (Cardinality) ключевых полей, требуемая для метода
  google.api.FieldBehavior key_field_behavior = 6;
  bool server_streaming = 7;
  bool client_streaming = 8;
  // Определение ключевых полей сущности для использования в методе
  // Переопределяет key_fields сервиса
  KeyFieldsDefinition key_fields_definition = 9;
  CustomComments custom_comments = 10;
  // TODO: Переименовать order_by_values
  repeated EnumValue order_by_set = 11;
  string linked_type_name = 12;
  // TODO: подстановка link_key_field_path по аналогии с ключами сущности
  string linked_key_path = 13;
  dto.RequestTemplate request_template = 14;
  dto.ResponseTemplate response_template = 15;
}

// TODO: примеры на расширяемость
// TODO: общий MethodTemplate с общими полями, может даже его включить в сервис
// TODO: вынести неиспользуемые в prerelease
// TODO: Подстановки сделать не {EntityTypeName}{LinkedTypeName}, а из полей метода и сущности {entity:type_name}{method:linked_type},
message SaveCreateReplace {
  option (name_template) = "Save{EntityTypeName}";
  option (request_name) = "Save{EntityTypeName}Request";
  option (response_name) = "Save{EntityTypeName}Response";
  option (response_template) = {one_entity_saving_error:{}};
  option (request_template) = {entity:{}};
  option (leading_comment) = "Метод создания/редактирования сущности {EntityTypeName}";
  option (http_rule) = {
    post: "/{HttpRoot}",
    body: "*"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
}

message SaveListCreateReplace {
  option (name_template) = "Save{EntityTypeName}List";
  option (request_name) = "Save{EntityTypeName}ListRequest";
  option (response_name) = "Save{EntityTypeName}ListResponse";

  option (http_rule) = {
    post: "/{HttpRoot}/list",
    body: "*"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
}

message SaveCreateOnly {
  option (name_template) = "Save{EntityTypeName}";
  option (request_name) = "Save{EntityTypeName}Request";
  option (response_name) = "Save{EntityTypeName}Response";
  option (http_rule) = {
    post: "/{HttpRoot}",
    body: "*"
  };
  option (key_field_behavior) = OUTPUT_ONLY;
}

message SaveListCreateOnly {
  option (name_template) = "Save{EntityTypeName}List";
  option (request_name) = "Save{EntityTypeName}ListRequest";
  option (response_name) = "Save{EntityTypeName}ListResponse";
  option (http_rule) = {
    post: "/{HttpRoot}/list",
    body: "*"
  };
  option (key_field_behavior) = OUTPUT_ONLY;
}

message EditById {
  option (name_template) = "Edit{EntityTypeName}";
  option (request_name) = "Edit{EntityTypeName}Request";
  option (response_name) = "Edit{EntityTypeName}Response";
  option (http_rule) = {
    patch: "/{HttpRoot}/{KeyFields}",
    body: "data"
  };
  option (key_field_behavior) = REQUIRED;
  // Определение ключевых полей сущности для использования в методе
  // Переопределяет key_fields сервиса
  KeyFieldsDefinition key_fields_definition = 1;
}

message Edit {
  option (name_template) = "Edit{EntityTypeName}";
  option (request_name) = "Edit{EntityTypeName}Request";
  option (response_name) = "Edit{EntityTypeName}Response";
  option (http_rule) = {
    patch: "/{HttpRoot}",
    body: "data"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
}

message EditList {
  option (name_template) = "Edit{EntityTypeName}List";
  option (request_name) = "Edit{EntityTypeName}ListRequest";
  option (response_name) = "Edit{EntityTypeName}ListResponse";
  option (http_rule) = {
    patch: "/{HttpRoot}/list",
    body: "data"
  };
  option (key_field_behavior) = REQUIRED;
}


message DeleteById {
  option (name_template) = "Delete{EntityTypeName}";
  option (request_name) = "Delete{EntityTypeName}Request";
  option (response_name) = "Delete{EntityTypeName}Response";
  option (leading_comment) = "Метод удаления единичной сущности {EntityTypeName} по ключу";
  option (response_template) = {valid_error:{}};
  option (request_template) = {entity_key:{}};
  option (http_rule) = {
    delete: "/{HttpRoot}/{KeyFields}"
  };
  option (key_field_behavior) = REQUIRED;
  // Переопределяет key_fields сервиса
  repeated string key_fields = 1;
  CustomComments custom_comments = 2;
}

message RestoreById {
  option (name_template) = "Post{EntityTypeName}Restore";
  option (request_name) = "Post{EntityTypeName}RestoreRequest";
  option (response_name) = "Post{EntityTypeName}RestoreResponse";
  option (leading_comment) = "Метод восстановлении удаленной сущности {EntityTypeName} по ключу";
  option (response_template) = {valid_error:{}};
  option (request_template) = {entity_key:{}};
  option (http_rule) = {
    post: "/{HttpRoot}/restore/{KeyFields}"
  };
  option (key_field_behavior) = REQUIRED;
  // Определение ключевых полей сущности для использования в методе
  // Переопределяет key_fields сервиса
  KeyFieldsDefinition key_fields_definition = 1;
  CustomComments custom_comments = 2;
}

message Delete {

  option (name_template) = "Delete{EntityTypeName}";
  option (request_name) = "Delete{EntityTypeName}Request";
  option (response_name) = "Delete{EntityTypeName}Response";
  option (http_rule) = {
    delete: "/{HttpRoot}"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
}

message DeleteList {

  option (name_template) = "Delete{EntityTypeName}List";
  option (request_name) = "Delete{EntityTypeName}ListRequest";
  option (response_name) = "Delete{EntityTypeName}ListResponse";
  option (http_rule) = {
    delete: "/{HttpRoot}"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
}

message GetById {
  option (name_template) = "Get{EntityTypeName}";
  option (request_name) = "Get{EntityTypeName}Request";
  option (response_name) = "Get{EntityTypeName}Response";
  option (response_template) = {entity_error:{}};
  option (request_template) = {entity_key:{}};
  option (leading_comment) = "Метод получения единичной сущности {EntityTypeName} по ключу";
  option (http_rule) = {
    get: "/{HttpRoot}/{KeyFields}"
  };
  option (key_field_behavior) = REQUIRED;
  // Определение ключевых полей сущности для использования в методе
  // Переопределяет key_fields сервиса
  KeyFieldsDefinition key_fields_definition = 1;
  CustomComments custom_comments = 2;
}

message Get {
  option (name_template) = "Get{EntityTypeName}";
  option (request_name) = "Get{EntityTypeName}Request";
  option (response_name) = "Get{EntityTypeName}Response";
  option (http_rule) = {
    get: "/{HttpRoot}"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
}

message GetList {
  option (name_template) = "Get{EntityTypeName}List";
  option (request_name) = "Get{EntityTypeName}ListRequest";
  option (response_name) = "Get{EntityTypeName}ListResponse";
  option (request_template) = {filter_paging:{}};
  option (response_template) = {entity_error:{}};
  option (leading_comment) = "Метод получения списка сущностей {EntityTypeName} по фильтру";
  option (http_rule) = {
    get: "/{HttpRoot}/list"
  };
  option (server_streaming) = true;
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
  // TODO: Переименовать order_by_values
  repeated EnumValue order_by_set = 2;
}

message GetCount {

  option (name_template) = "Get{EntityTypeName}Count";
  option (request_name) = "Get{EntityTypeName}CountRequest";
  option (response_name) = "Get{EntityTypeName}CountResponse";
  option (request_template) = {filter:{}};
  option (response_template) = {count_entity_error:{}};
  option (leading_comment) = "Метод получения количества сущностей {EntityTypeName} по фильтру";
  option (http_rule) = {
    get: "/{HttpRoot}/count"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
}

// TODO: в extension  Exists

// TODO: в extension ExistsKey

// TODO: в extension AttachList
// TODO: в extension DetachList

message Attach {
  option (name_template) = "Put{EntityTypeName}{LinkedTypeName}Attach";
  option (request_name) = "Put{EntityTypeName}{LinkedTypeName}AttachRequest";
  option (response_name) = "Put{EntityTypeName}{LinkedTypeName}AttachResponse";
  option (request_template) = {link:{}};
  option (response_template) = {valid_error:{}};
  option (leading_comment) = "Метод привязки {EntityTypeName} и {LinkedTypeName}";
  option (http_rule) = {
    put: "/{HttpRoot}/{LinkedKeyPath}/attach"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
  string linked_type_name = 2;
  string linked_key_path = 3;
}

message Detach {
  option (name_template) = "Put{EntityTypeName}{LinkedTypeName}Detach";
  option (request_name) = "Put{EntityTypeName}{LinkedTypeName}DetachRequest";
  option (response_name) = "Put{EntityTypeName}{LinkedTypeName}DetachResponse";
  option (request_template) = {link:{}};
  option (response_template) = {valid_error:{}};
  option (leading_comment) = "Метод отвязки {EntityTypeName} и {LinkedTypeName}";
  option (http_rule) = {
    put: "/{HttpRoot}/{LinkedKeyPath}/detach"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
  string linked_type_name = 2;
  // TODO: подстановка link_key_field_path по аналогии с ключами сущности
  string linked_key_path = 3;
}

message GetLinkList {
  option (name_template) = "Get{EntityTypeName}{LinkedTypeName}List";
  option (request_name) = "Get{EntityTypeName}{LinkedTypeName}ListRequest";
  option (response_name) = "Get{EntityTypeName}{LinkedTypeName}ListResponse";
  option (request_template) = {link_filter_paging:{}};
  option (response_template) = {entity_error:{}};
  option (leading_comment) = "Метод получения списка связей {EntityTypeName} и {LinkedTypeName} по фильтру";
  option (http_rule) = {
    get: "/{HttpRoot}/{LinkedTypeName}/list"
  };
  option (server_streaming) = true;
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
  // TODO: Переименовать order_by_values
  repeated EnumValue order_by_set = 2;
  string linked_type_name = 3;
}

message GetLinkCount {
  option (name_template) = "Get{EntityTypeName}{LinkedTypeName}Count";
  option (request_name) = "Get{EntityTypeName}{LinkedTypeName}CountRequest";
  option (response_name) = "Get{EntityTypeName}{LinkedTypeName}CountResponse";
  option (request_template) = {link_filter:{}};
  option (response_template) = {count_entity_error:{}};
  option (leading_comment) = "Метод получения количества связей {EntityTypeName} и {LinkedTypeName} по фильтру";
  option (http_rule) = {
    get: "/{HttpRoot}/{LinkedTypeName}/count"
  };
  option (key_field_behavior) = FIELD_BEHAVIOR_UNSPECIFIED;
  CustomComments custom_comments = 1;
  string linked_type_name = 2;
}


