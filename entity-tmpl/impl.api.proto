syntax = "proto3";

import "google/protobuf/descriptor.proto";
import "impl.api.service.proto";
import "entity.feature.api.proto";

package impl.api;

// TODO: обойтись без спецификации, сразу сервис
extend google.protobuf.MessageOptions {
  // Шаблон спецификации Rev1
  Specification specification = 3001 [(entity.feature.api.specification) = "impl.rev1"];
}

// Шаблон спецификации Rev1
message Specification {
  option (specification) =
  {
    serverside_entity_crud:
    {
      override_attributes:{
        leading_comment: "Сервис управления сущностью {EntityTypeName}";
      }
      attributes:{
        name: "{EntityTypeName}Service"
      }
      method_set: {
        get:{
          attributes:{
            default:{
              leading_comment: "Метод получения единичной сущности {EntityTypeName} по ключу"
            }
            name:"Get{EntityTypeName}"
            request_name: "Get{EntityTypeName}Request"
            response_name: "Get{EntityTypeName}Response"
            http_rule:{
              get: "/{HttpRoot}/{KeyFields}"
            }
            key_field_behavior: REQUIRED
          }
          response_template: {entity_error:{}}
          request_template: {entity_key:{}}
        }
        get_list:{
          attributes:{
            default:{
              leading_comment: "Метод получения списка сущностей {EntityTypeName} по фильтру"
            }
            name:"Get{EntityTypeName}List"
            request_name:"Get{EntityTypeName}ListRequest"
            response_name:"Get{EntityTypeName}ListResponse"
            http_rule: {
              get: "/{HttpRoot}/list"
            }
            server_streaming: true
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED
          }
          request_template: {filter_paging:{}}
          response_template: {entity_error:{}}
        }
        save_create_replace: {
          attributes:{
            default: {
              leading_comment: "Метод создания/редактирования сущности {EntityTypeName}"
            }
            name: "Save{EntityTypeName}"
            request_name: "Save{EntityTypeName}Request"
            response_name: "Save{EntityTypeName}Response"
            http_rule: {
              post: "/{HttpRoot}",
              body: "*"
            }
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED
          }
          response_template: {entity_saving_error:{}}
          request_template: {entity:{}}
        }
        get_count:{
          attributes:{
            default:{
              leading_comment: "Метод получения количества сущностей {EntityTypeName} по фильтру"
            }
            name: "Get{EntityTypeName}Count"
            request_name: "Get{EntityTypeName}CountRequest"
            response_name: "Get{EntityTypeName}CountResponse"
            http_rule: {
              get: "/{HttpRoot}/count"
            }
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED;
          }
          request_template: {filter:{}}
          response_template: {count_entity_error:{}}
        }
        get_link_count: {
          attributes:{
            default:{
              leading_comment: "Метод получения количества связей {EntityTypeName} и {LinkedTypeName} по фильтру"
            }
            name: "Get{EntityTypeName}{LinkedTypeName}Count"
            request_name: "Get{EntityTypeName}{LinkedTypeName}CountRequest";
            response_name: "Get{EntityTypeName}{LinkedTypeName}CountResponse"
            http_rule: {
              get: "/{HttpRoot}/{LinkedTypeName}/count"
            }
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED
          }
          request_template: {link_filter:{}};
          response_template: {count_entity_error:{}};
        }
        get_link_list:{
          attributes:{
            default:{
              leading_comment: "Метод получения списка связей {EntityTypeName} и {LinkedTypeName} по фильтру"
            }
            name: "Get{EntityTypeName}{LinkedTypeName}List"
            request_name: "Get{EntityTypeName}{LinkedTypeName}ListRequest"
            response_name: "Get{EntityTypeName}{LinkedTypeName}ListResponse"
            http_rule: {
              get: "/{HttpRoot}/{LinkedTypeName}/list"
            };
            server_streaming: true
          }
          request_template: {link_filter_paging:{}}
          response_template: {link_error:{}}
        }
        delete:{
          attributes:{
            default:{
              leading_comment: "Метод удаления единичной сущности {EntityTypeName} по ключу"
            }
            name: "Delete{EntityTypeName}"
            request_name: "Delete{EntityTypeName}Request"
            response_name: "Delete{EntityTypeName}Response"
            http_rule: {
              delete: "/{HttpRoot}/{KeyFields}"
            }
            key_field_behavior: REQUIRED
          }
          response_template: {valid_error:{}}
          request_template: {entity_key:{}}
        }
        restore: {
          attributes:{
            default:{
              leading_comment: "Метод восстановления удаленной сущности {EntityTypeName} по ключу"
            }
            name: "Post{EntityTypeName}Restore"
            request_name: "Post{EntityTypeName}RestoreRequest"
            response_name: "Post{EntityTypeName}RestoreResponse"
            http_rule: {
              post: "/{HttpRoot}/restore/{KeyFields}"
            }
            key_field_behavior: REQUIRED
          }
          response_template: {valid_error:{}}
          request_template: {entity_key:{}}
        }
        attach:{
          attributes:{
            default:{
              leading_comment: "Метод привязки {EntityTypeName} и {LinkedTypeName}"
              request_leading_comment: "Запрос на добавление связи {EntityTypeName} и {LinkedTypeName}";
              response_leading_comment: "Ответ на запрос на добавление связи {EntityTypeName} и {LinkedTypeName}";
            }
            name: "Put{EntityTypeName}{LinkedTypeName}Attach"
            request_name: "Put{EntityTypeName}{LinkedTypeName}AttachRequest"
            response_name: "Put{EntityTypeName}{LinkedTypeName}AttachResponse"
            http_rule: {
              put: "/{HttpRoot}/{LinkKeyFieldPath}/attach"
            }
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED
          }
          request_template: {link:{}}
          response_template: {valid_error:{}}
        }
        detach:{
          attributes:{
            default:{
              leading_comment: "Метод отвязки {EntityTypeName} и {LinkedTypeName}"
              request_leading_comment: "Запрос на удаление связи {EntityTypeName} и {LinkedTypeName}"
              response_leading_comment: "Ответ на запрос на удаление связи {EntityTypeName} и {LinkedTypeName}"
            }
            name: "Put{EntityTypeName}{LinkedTypeName}Detach"
            request_name: "Put{EntityTypeName}{LinkedTypeName}DetachRequest"
            response_name: "Put{EntityTypeName}{LinkedTypeName}DetachResponse"
            http_rule: {
              put: "/{HttpRoot}/{LinkKeyFieldPath}/detach"
            }
            key_field_behavior: FIELD_BEHAVIOR_UNSPECIFIED
          }
          request_template: {link:{}}
          response_template: {valid_error:{}}
        }
      }
    }
  };
  oneof service {
    service.ServersideEntityCRUD serverside_entity_crud = 1;
    //    service.ServersideSingletonCRUD serverside_singleton_crud = 2;
  }
}

